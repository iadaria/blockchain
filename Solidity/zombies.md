### Модификатор функции onlyOwner (единственный владелец)

Теперь базовый контракт ZombieFactory наследует Ownable и мы можем использовать модификатор onlyOwner в ZombieFeeding.

Запомни, как работает наследование в контрактах:

ZombieFeeding is ZombieFactory
ZombieFactory is Ownable

Таким образом, ZombieFeeding также и Ownable, он может получить доступ к функциям, событиям и модификаторам контракта Ownable. Это относится к любым контрактам, которые будут наследовать ZombieFeeding в будущем.
Модификаторы функций

Модификатор функции выглядит точно так же, как сама функция, но использует ключевое слово modifier вместо function. Его нельзя вызвать напрямую, как функцию - вместо этого мы можем добавить модификатор в конце определения функции и изменить ее поведение.

Рассмотрим на примере onlyOwner:

```javascript
/**
 * @dev Throws if called by any account other than the owner.
 */
modifier onlyOwner() {
  require(msg.sender == owner);
  _;
}

Используем модификатор:

contract MyContract is Ownable {
  event LaughManiacally(string laughter);

  // Обрати внимание на использование `onlyOwner` ниже:
  function likeABoss() external onlyOwner {
    LaughManiacally("Muahahahaha");
  }
}
```

Видишь модификатор onlyOwner в функции likeABoss? Когда ты вызываешь likeABoss, в первую очередь выполняется код внутри onlyOwner. Затем, когда он доходит до оператора _; в onlyOwner, он возвращается и выполняет код внутри likeABoss.

Хотя есть и другие способы использования модификаторов, одним из наиболее распространенных вариантов является добавление быстрой проверки require перед выполнением функции.

Добавление модификатора onlyOwner в функцию делает так, что только единственный владелец, например ты, может вызвать эту функцию.

    Примечание: предоставление владельцу особой власти над подобным контрактом часто необходимо. Но властью можно злоупотреблять: например, 
    владелец может оставить бэкдор, который переведет всех зомби на его адрес!

    Важно помнить, что DApp на Ethereum не означает децентрализацию по умолчанию. Читай исходники, чтобы убедиться, что контракт не содержит средств 
    передачи контроля другому владельцу. Разработчику необходимо найти баланс между контролем над DApp для исправления багов, и созданием децентрализованной
     платформы, которой пользователи могут доверять.


### Собственные контракты

Насчет дыры в безопасности в предыдущей главе.

Функция setKittyContractAddress — внешняя external, ее может вызвать кто угодно! Это означает, что любой вызвавший функцию может заменить адрес контракта Криптокотиков и испортить игру всем остальным.

Нам нужна возможность обновления адреса в контракте, но также надо закрыть возможность обновления всем остальным.

Для подобных случаев есть одна распространенная практика: делать контракты Ownable — собственными, то есть принадлежащими тебе и дающими особые привилегии.
Собственный контракт OpenZeppelin

Ниже пример Ownable контракта из библиотеки Solidity OpenZeppelin. OpenZeppelin - это библиотека безопасных смарт-контрактов сообщества, которыми можно пользоваться для личных DApps. Пока ты будешь ждать Урока 4, посмотри библиотеки на этом сайте. Поможет в дальнейшем.

Прочитай контракт ниже. Ты увидишь несколько неизученных моментов, не волнуйся, сейчас мы поговорим о них.

```javascript
/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
```

Вот что мы не видели раньше:

    Конструкторы: function Ownable() это конструктор, особая опциональная функция с таким же именем, как контракт. 
    Выполняется только один раз в момент создания контракта.
    Модификаторы функции: modifier onlyOwner(). Модификаторы — полуфункции, которые используются для изменения других 
    функций, обычно для проверки некоторых требований до их выполнения. В этом случае onlyOwner можно использовать для ограничения
     доступа, чтобы только владелец контракта мог запустить эту функцию. В следующей главе мы подробно поговорим о модификаторах функций, 
     а также о странном _; и его назначении. Ключевое слово indexed: пока не нужно, об этом потом.

В целом Ownable контракт делает следующее:

    Когда контракт создается, конструктор присваивает msg.sender (развернувшему контракт) атрибут owner.

    Он добавляет модификатор onlyOwner, который может ограничить доступ к определенным функциям, предоставив его только владельцу owner.

    Он позволяет передать контракт новому owner.

onlyOwner настолько распространенное требование для контрактов, что большинство DApps Solidity начинаются с копирования/вставки Ownable контракта, а следующий контракт наследует ему.

Поскольку мы хотим ограничить setKittyContractAddress только для onlyOwner, сделаем то же самое и для нашего контракта.

### Неизменяемость контрактов

До сих пор Solidity был похож на другие языки программирования, например на JavaScript. Но у Ethereum DApps есть несколько важных отличий от обычных приложений.

Первое — после развертывания на Ethereum контракта он становится неизменяемым. Это значит, что он никогда не сможет быть модифицирован или обновлен.

Первоначально развернутый в контракте код останется в блокчейне навсегда. Это одна из самых неприятных проблем с безопасностью в Solidity. Если в коде контракта есть недостаток, позже его не удастся исправить. Тебе придется убедить пользователей перейти на исправленный адрес смарт-контракта.

Одновременно это и преимущество смарт-контрактов. Код - это закон. Если прочесть и проверить код смарт-контракта, то можно не волноваться: каждый раз при вызове функция будет делать именно то, что написано в коде. Никто не может впоследствии изменить функцию и задать ей незаявленное поведение.
Внешние зависимости

Во втором уроке мы зашили адрес контракта Криптокотиков в DApp. Но что произойдет, если в контракте Криптокотиков обнаружится баг или кто-то уничтожит всех котиков?

Это маловероятно, но если вдруг подобное произойдет, то наш DApp станет совершенно бесполезным - он будет указывать на адрес, который больше не возвращает котиков. Зомби не смогут питаться котятами, а мы не сможем починить контракт.

По этой причине имеет смысл предустмотреть функции, позволяющие обновлять ключевые части DApp.

Например, вместо того, чтобы зашивать адрес контракта Криптокотиков в DApp, лучше предусмотреть функцию setKittyContractAddress (задать адрес котоконтракта). Если в контракте Криптокотиков что-то пойдет не так, она позволит в будущем изменить адрес. 

### Работа с несколькими возвращаемыми значениями

Функция getKitty — первый видимый нами пример возвращения множественных значиний. Посмотрим, как с ними обращаться:

```javascript
function multipleReturns() internal returns(uint a, uint b, uint c) {
  return (1, 2, 3);
}

function processMultipleReturns() external {
  uint a;
  uint b;
  uint c;
  // Вот как выполнять несколько заданий:
  (a, b, c) = multipleReturns();
}

// А если нам важно только одно значение...
function getLastReturnValue() external {
  uint c;
  // ...мы просто оставим другое поле пустым
  (,,c) = multipleReturns();
}
```

### Используем интерфейс

Продолжим наш предыдущий пример с NumberInterface, как только зададим интерфейс:

contract NumberInterface {
  function getNum(address _myAddress) public view returns (uint);
}

Мы можем использовать его в контракте следующим образом:

```javascript
contract MyContract {
  address NumberInterfaceAddress = 0xab38... 
  // ^ Адрес контракта FavoriteNumber в Ethereum
  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress)
  // Сейчас `numberContract` указывает на другие контракты

  function someFunction() public {
    // Теперь можно вызвать `getNum` из контракта:
    uint num = numberContract.getNum(msg.sender);
    // ...и сделать что-то с `num` здесь
  }
}
```

Этим способом контракт будет взаимодействовать с всеми другими контрактами в блокчейне Ethereum, если они задают функции как public (открытые) или external (внешние). 

### Взаимодействие с другими контрактами

Чтобы наш контракт связался с другим контрактом в блокчейне, которым владеем не мы, сначала нужно определить интерфейс.

Посмотрим простой пример. Допустим, в блокчейне существует такой контракт:

```javascript
contract LuckyNumber {
  mapping(address => uint) numbers;

  function setNum(uint _num) public {
    numbers[msg.sender] = _num;
  }

  function getNum(address _myAddress) public view returns (uint) {
    return numbers[_myAddress];
  }
}
```

Это простой контракт, где каждый может хранить свой счастливый номер, связаный с личным адресом Ethereum. Тогда любой может найти счастливый номер человека по адресу.

Теперь допустим, что у нас есть другой внешний контракт, который хочет считать данные в этом контракте, используя функцию getNum.

Сначала нам надо будет определить интерфейс контракта LuckyNumber (счастливый номер):

contract NumberInterface {
  function getNum(address _myAddress) public view returns (uint);
}

Это похоже на определение контракта, но есть несколько отличий. Во-первых, мы объявляем только те функции, с которыми хотим взаимодействовать - в данном случае getNum - и не упоминаем другие функции или переменные состояния.

Во-вторых, мы не определяем тела функций. Вместо фигурных скобок ({ и }) мы заканчиваем задание функции точкой с запятой (;).

Это как скелет контракта. Так компилятор узнает, что это интерфейс.

Если включить интерфейс в код DApp, наш контракт узнает, как выглядят функции другого контракта, как их вызвать и какой придет ответ.

В следующем уроке мы будем вызывать функции другого контракта, а пока зададим интерфейс для контракта Криптокотиков.

### Внутренние и внешние функции

В дополнение к открытым и закрытым, в Solidity есть еще два типа видимости для функций: internal (внутренняя) и external (внешняя).

internal (внутренняя) это почти как private (закрытая), разница лишь в том, что к нему могут получить доступ только контракты, которые наследуют этому контракту. (Звучит как полная ерунда!).

external (внешний) это как public (открытая), с той лишь разницей, что она может быть вызвана ТОЛЬКО за пределами контракта — другими функциями вне его. Позже поговорим о том, когда использовать external а когда public функции.

Для internal или external функций синтаксис такой же, как в private and public:

```javascript
contract Sandwich {
  uint private sandwichesEaten = 0;

  function eat() internal {
    sandwichesEaten++;
  }
}

contract BLT is Sandwich {
  uint private baconSandwichesEaten = 0;

  function eatWithBacon() public returns (string) {
    baconSandwichesEaten++;
    // Можно вызвать функцию, потому что она внутренняя
    eat();
  }
}
```


### Хранилище и память

В Solidity есть два места, где могут сохраняться переменные: в storage (хранилище) и в memory (памяти).

Хранилище используют, чтобы сохранить переменные в блокчейн навсегда. Память используют для временного хранения переменных, они стираются в промежутках, когда внешняя функция обращается к контракту. Это похоже на жесткий диск компьютера и оперативную память.

В большинстве случаев тебе не придется использовать ключевые слова, потому что Solidity определяет по умолчанию, что куда сохранять. Переменные состояния (заданные вне функции) по умолчанию хранятся записанными в блокчейне. Переменные, заданные внутри функции, пишутся в память и исчезнут, как только вызов функции закончится.

Тем не менее, есть случаи, когда обязательно надо указывать ключевые слова, а именно когда ты работаешь со структурами и массивами в пределах функции:

```javascript
contract SandwichFactory {
  struct Sandwich {
    string name;
    string status;
  }

  Sandwich[] sandwiches;

  function eatSandwich(uint _index) public {
    // Сэндвич mySandwich = sandwiches[_index];

    // ^ Вроде все в порядке, но Solidity выдаст предупреждение, 
    // что надо ясно указать `storage` или `memory`.

    // Поэтому используй ключевое слово `storage`, вот так: 
    Sandwich storage mySandwich = sandwiches[_index];
    // ...где `mySandwich` указывает на `sandwiches[_index]` в хранилище, и...
    mySandwich.status = "Eaten!";
    // ...навсегда изменит `sandwiches[_index]` в блокчейне.

    // Если нужна просто копия, используй `memory`:
    Sandwich memory anotherSandwich = sandwiches[_index + 1];
    // ...тогда `anotherSandwich` будет простой копией данных в памяти, таким образом... 
    anotherSandwich.status = "Eaten!";
    // ...всего лишь модифицирует временную переменную и не окажет влияния
    // на `sandwiches[_index + 1]`. Но ты можешь сделать и так... 
    sandwiches[_index + 1] = anotherSandwich;
    // ...если надо сохранить данные в блокчейне.
  }
}

```
Не волнуйся, если пока не все ясно — на протяжение курса мы подскажем, когда использовать storage, а когда memory. Компилятор Solidity тоже выдает предупреждение, когда нужно использовать одно из этих ключевых слов.

На данный момент достаточно принять как факт, что есть случаи, требующие ясного обозначения storage или memory! 

### Импорт

Зацени! Мы снесли код справа, и теперь у тебя есть вкладки в верхней части редактора. Вперед, попереключайся между вкладками, чтобы попробовать.

Код уже довольно длинный, поэтому мы разбили его на несколько файлов, чтобы сделать его более послушным. Именно так управляют длинным кодом в проектах Solidity.

Когда у тебя несколько файлов и нужно импортировать один в другой, Solidity использует ключевое слово import:

import "./someothercontract.sol";

contract newContract is SomeOtherContract {

}

Если у нас есть файл someothercontract.sol в той же директории, что и этот контракт (/ нам говорит об этом), то компилятор импортирует его.

### Наследование

Код уже довольно длинный! Чтобы не делать один длиннющий контракт и организовать код, можно разбить логику кода на несколько контрактов.

В Solidity есть фича, которая помогает управлять длинными контрактами — наследование:

```javascript
contract Doge {
  function catchphrase() public returns (string) {
    return "Клевый песик";
  }
}

contract BabyDoge is Doge {
  function anotherCatchphrase() public returns (string) {
    return "Клевый щеночек";
  }
}
```

BabyDoge (щенок) наследует Doge (Псу!). Если ты скомпилируешь и развернешь BabyDoge, он получит доступ и к catchphrase() и к anotherCatchphrase() (и ко всем остальным открытым функциям, которые мы опишем в Doge).

Это можно использовать для логического наследования (как с подтипами, Cat (кошка) это Animal (животное)), или для простой организации кода, группируя вместе одинаковую логику внутри различных классов. 

### Требование
Используем require (требование). require делает так, что функция выдает ошибку и прекращает выполнение. если одно из условий не верно: 

```javascript
function sayHiToVitalik(string _name) public returns (string) {
  // Сравнивает, если _имя равно "Vitalik". Выдает ошибку и закрывается, если не верно.
  // (Примечание: в Solidity нет родного сравнивателя строк, поэтому
  // мы сравниваем их keccak256-хэши, чтобы увидеть, равны они или нет
  require(keccak256(_name) == keccak256("Vitalik"));
  // Если верно, то переходим к выполнению функции:
  return "Привет!";
}
```

### Отправитель

Теперь, когда у нас есть карта соответсвий для отслеживания владельцев зомби, надо обновить метод _createZombie.

Для этого нам понадобится msg.sender (отправитель).

**В Solidity существуют определенные глобальные переменные, доступные всем функциям. Одной из них является msg.sender (отправитель), который ссылается на address (адрес) человека или смарт-контракта, вызвавшего текущую функцию.**

    Примечание: В Solidity выполнение функции всегда начинается с внешнего вызова. Контракт в блокчейне ничего не делает, пока кто-то не вызовет одну из его функций. Поэтому всегда будет нужен msg.sender.

Пример использования msg.sender для обновления mapping:

```javascript
mapping (address => uint) favoriteNumber;

function setMyNumber(uint _myNumber) public {
  // Обнови соответсвие `favoriteNumber`, чтобы сохранить `_myNumber` под `msg.sender`
  favoriteNumber[msg.sender] = _myNumber;
  // ^ Синтаксис для сохранения в карте соответствия такой же, как для массива
}

function whatIsMyNumber() public view returns (uint) {
  // Затребуй значение, сохраненное в адресе отправителя 
  // Оно будет равно `0`, если отправитель еще не вызывал `setMyNumber`
  return favoriteNumber[msg.sender];
}
```

### Соответствия

В первом уроке мы рассмотрели структуры и массивы. Соответствия — это еще один способ хранения упорядоченных данных в Solidity.

Определение mapping (соответствий) выглядит как-то так:

// Для финансового приложения мы храним uint, который содержит остаток на счете пользователя: 
mapping (address => uint) public accountBalance;
// Или может использоваться для хранения / поиска имен пользователей на основе userId 
mapping (uint => string) userIdToName;

Соответствия - это, по сути, распределенное хранилище типа «ключ — значение», в котором можно хранить и искать данные. В первом примере ключ — это «адрес», а значение - «uint», а во втором примере ключ - «uint», а значение — «строка». 

### Адреса

Блокчейн Ethereum состоит из аккаунтов (счетов), вроде банковских. На аккаунте находится баланс Эфира (криптовалюты блокчейна Ethereum). Ты можешь отправлять и получать платежи в Эфире на другие счета, также как ты переводишь деньги со своего банковского счета на счета других людей.

У каждого счета есть address (адрес), наподобие номера банковского счета. Это уникальный идентификатор счета, который выглядит так:

0x0cE446255506E92DF41614C46F1d6df9Cc969183

(Этот адрес принадлежит команде Криптозомби. Если тебе нравится игра, можешь послать нам эфир!😉).

Мы изучим самое важное блокчейн-адресов в следующем уроке, сейчас же достаточно знать, что адрес принадлежит определенному человеку (или контракту).

Поэтому мы можем использовать его как уникальный идентификатор принадлежности зомби. Когда пользователь создает нового зомби, взаимодействуя с нашим приложением, мы привязываем право собственности на зомби к адресу Ethereum, который вызвал функцию. 

### web3.js
В Ethereum есть библиотека Javascript под названием Web3.js.

```javascript
// Как осуществляется доступ к контракту:
var abi = /* abi generated by the compiler */
var ZombieFactoryContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var ZombieFactory = ZombieFactoryContract.at(contractAddress)
// `ZombieFactory` получил доступ к открытым функциям и событиям

// «Слушатель» событий принимает введенный текст 
$("#ourButton").click(function(e) {
  var name = $("#nameInput").val()
  // Вызываем функцию контракта `createRandomZombie`:
  ZombieFactory.createRandomZombie(name)
})

// Слушаем событие `NewZombie` и обновляем UI (интерфейс)
var event = ZombieFactory.NewZombie(function(error, result) {
  if (error) return
  generateZombie(result.zombieId, result.name, result.dna)
})

// Возьмем ДНК зомби и обновим изображение 
function generateZombie(id, name, dna) {
  let dnaStr = String(dna)
  // Заполним ячейки нулями, если ДНК получилось меньше 16 знаков 
  while (dnaStr.length < 16)
    dnaStr = "0" + dnaStr

  let zombieDetails = {
    // Первые 2 цифры задают голову. Всего возможно 7 вариантов голов, поэтому % 7
    // Получить цифры от 0 до 6, затем добавить 1, чтобы сделать их от 1 до 7. Так будет 7 вариантов
    // Файлы с именами от "head1.png" до "head7.png" загружаем, исходя из этого номера:
    headChoice: dnaStr.substring(0, 2) % 7 + 1,
    // Вторые 2 цифры задают глаза, 11 вариантов:
    eyeChoice: dnaStr.substring(2, 4) % 11 + 1,
    // 6 вариантов мундиров:
    shirtChoice: dnaStr.substring(4, 6) % 6 + 1,
    // Последние 6 цифр задают цвет. Обновления используют фильтр CSS с углом поворота 360 градусов:
    skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360),
    eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360),
    clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360),
    zombieName: name,
    zombieDescription: "A Level 1 CryptoZombie",
  }
  return zombieDetails
}

```
### События
Событие — это способ, которым контракт сообщает внешнему интерфейсу приложения, что в блокчейне произошло некое событие. Интерфейс может «услышать» определенные события и выполнить заданное действие по его наступлении.

Пример:
// Объяви событие
`event IntegersAdded(uint x, uint y, uint result);
function add(uint _x, uint _y) public {
  uint result = _x + _y;
  // Запусти событие, чтобы оповестить приложение о вызове функции:
  IntegersAdded(_x, _y, result);
  return result;
}`

Теперь внешний интерфейс приложения сможет услышать событие. Примерно так будет выглядеть выполнение javascript:

YourContract.IntegersAdded(function(error, result) {
  // Воспользуйся результатом
})

### Random и преобразование
В Ethereum есть встроенная хэш-функция keccak256 (произносится как «кечак»), разновидность SHA3. Хеш-функция обычно преображает входную строку в случайное 256-битное шестнадцатеричное число. Небольшое изменение в строке приведет к сильному изменению хэша.

Эта функция полезна для выполнения многих задач в Ethereum, но сейчас мы используем ее для обычной генерации псевдослучайных чисел.

Пример:

//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5
keccak256("aaaab");
//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9
keccak256("aaaac");
Как видишь, функция возвращает абсолютно другое значение, хотя мы изменили всего одну входную букву.
//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5
keccak256(abi.encodePacked("aaaab"));
//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9
keccak256(abi.encodePacked("aaaac"));

Примечание: в блокчейне остро стоит проблема генерации безопасных случайных чисел. Приведенный нами метод небезопасен, но для текущей задачи годится, поскольку безопасность не входит в приоритетные задачи ДНК зомби.

Преобразование типов данных
Периодически типы данных надо конвертировать. Смотри пример:

uint8 a = 5;
uint b = 6;
// Выдаст ошибку, потому что a * b возвращает uint, а не uint8:
uint8 c = a * b; 
// Чтобы код работал, нужно преобразовать b в uint8:
uint8 c = a * uint8(b); 
В примере выше a * b возвращал uint, но мы попытались сохранить его как uint8, что потенциально могло привести к проблемам. Если преобразовать тип данных в uint8, то код будет работать, а компилятор не выдаст ошибку.

### Модификаторы функций
По умолчанию функции в Solidity public (открытые): любой человек или контракт может вызвать и исполнить функцию твоего контракта
Разумеется, это не всегда желательно, потому что в контракте могут найтись уязвимости для атак. Лучше по умолчанию помечать функции как «закрытые» и потом задавать «открытые» функции, которые не страшно выставить на всеобщее обозрение.
`uint[] numbers;
function _addToArray(uint _number) private {
  numbers.push(_number);
}`

Вернуть значение
Как задать функцию, чтобы она возвращала значение:
`string greeting = "Привет, дружок";
function sayHello() public returns (string) {
  return greeting;
}`
Задание функции в Solidity содержит тип возвращаемого значения (в данном случае string).

Модификаторы функций
Рассмотренная выше функция не модифицирует свое состояние — не изменяет значения и не переписывает что-либо.

Поэтому в данном случае мы можем задать функцию просмотр – просмотр данных без их изменения:
`function sayHello() public view returns (string) {
Еще в Solidity есть чистые функции — ты не получишь доступ к данным в приложении. Рассмотрим пример:

function _multiply(uint a, uint b) private pure returns (uint) {
  return a * b;
}`
Функция даже не читает состояние приложения - она возвращает значение, которое зависит только от параметров самой функции. В этом случае мы задаем функцию как pure.

Примечание: не всегда легко вспомнить, когда задать «чистую» функцию или «просмотр». К счастью, компилятор Solidity исправно выдает предупреждения, что нужно использовать тот или иной модификатор.

**Переменные состояния** записываются в хранилище контракта. Это означает, что они сохраняются в блокчейне Ethereum, как в базе данных.

Пример:
contract Example {
  // Контракт навсегда сохранен в блокчейне 
  uint myUnsignedInteger = 100;
}

> Примечание: в Solidity uint используют как синоним для uint256, 256-битного целого числа без знака. Можно задать uint с меньшим количество
> битов — uint8, uint16, uint32 и.т.д. Но обычно используют просто uint, кроме особенных случаев, о которых мы поговорим далее.

Математика в Solidity довольна проста. Операции точно такие же, как в большинстве языков программирования:

Сложение: x + y
Вычитание: x - y,
Умножение: x * y
Деление: x / y
Модуль и остаток от деления: x % y (например, 13 % 5 будет равно 3, если разделить 13 на 5, в остатке 3)
Solidity поддерживает экспоненциальные операции exponential operator — возведение в степень (например "x в степени y", x^y):

uint x = 5 ** 2; // 5 в квадрате = 25

### Структуры 

struct Person {
  uint age;
  string name;
}

С помощью структур ты создашь более сложные типы данных с несколькими свойствами.

### Массивы

Если нужен список из похожих элементов, подойдет массив. В Solidity есть два типа массивов: фиксированный и динамический:

// Массив фиксированной длины из 2 элементов:
uint[2] fixedArray;
// Другой фиксированный массив из 5 строк:
string[5] stringArray;
// Динамический массив не ограничен по размеру и может увеличиваться:
uint[] dynamicArray;

Ты можешь создать массив из структур. Возьми структуру Person из предыдущей части:
Person[] people; // Динамический массив позволяет добавлять в него данные

Ты не забыл, что переменные состояния сохраняются в блокчейне навсегда? Создание динамического массива из подобных структур полезно 
для хранения структурированных данных внутри контракта, как в базе данных.

### Открытые массивы
Можно задать массив как public (открытый), и Solidity автоматически создаст для него геттер (способ получения). Синтаксис:

Person[] public people;
В этом случае другие контракты смогут читать этот массив (но не писать в него). Это образец хранения открытых данных в контракте.

### Функции

Примечание: обычно (но не обязательно) имена переменных в параметрах функций записывают со знаком подчеркивания в начале,
 чтобы было проще отличить их от глобальных переменных. В наших урокам мы тоже будем пользоваться этим обычаем.

 ### Массивы

 uint[] numbers;
numbers.push(5);
numbers.push(10);
numbers.push(15);
// Числа равны [5, 10, 15]